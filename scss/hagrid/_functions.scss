
///////////////////////////////
// FUNCTIONS
///////////////////////////////

// Main Parser
//////////////////////////////

@mixin grid-calc($prop, $widths...) {
    $arg-length: length($widths);

    @if $arg-length == 0 {
        // * If no params are passed, default to mobile-first
        @if $prop == flex-basis {
            #{$prop}: 100%;
        }
        @else {
            @error "You need to pass at least one statement to push/pull";
        }
    }
    @else {
        $width-detected: false;

        @for $i from 1 through length($widths) {
            $width: nth($widths,$i);

            // * If a general width is passed in, use it
            @if type-of($width) == number {
                #{$prop}: calculate-width($width);
                $width-detected: true;
            }
            // * If false is passed, assign no width
            @elseif $width == false {
                $width-detected: true;
            }
            // * If auto is passed, assign no width
            @elseif $width == auto {
                flex: 1 1 auto;
                $width-detected: true;
            }
            // * Handle responsive args
            @else {
                // * "md 2/3"-synthax
                $key: nth($width, 1);
                $value: nth($width, 2);

                // * Cater for "2/3 md"-synthax
                @if type-of($key) == number {
                    $value: nth($width, 1);
                    $key: nth($width, 2);
                }

                // * Cater for specific breakpoints
                $bp: parse-breakpoint($key);

                @if $bp != false {
                    @include bp(#{$key}) {
                        @if type-of($value) == number {
                            #{$prop}: calculate-width($value);
                        }
                        @else if $value == auto {
                            flex: 1 1 auto;
                        }
                        @else if $value == false {
                            @error "You cannot pass false to breakpoint #{$key}."
                        }
                    }
                }
                @else {
                    @warn "You are trying to assign a width to an unknown, unquoted breakpoint: #{$key}";
                }
            }
        }

        // * If only responsive params are passed, default to mobile-first
        @if $width-detected == false and $prop == flex-basis {
            #{$prop}: 100%;
        }
    }
}

// Calculate Width (Fraction => Percentage)
//////////////////////////////

@function calculate-width($value) {
    @if unit($value) != "" {
        @return $value;
    }
    @else {
        @return ($value * 100 * 1%);
    }
}

// Gutter Modifier Functions
//////////////////////////////

@function hagrid-gutter-exists($id) {
    @return map-has-key($hagrid-gutters, $id);
}

@function hagrid-gutter-get($id) {
    @return map-get($hagrid-gutters, $id);
}

// Breakpoint Validity Checker
// Validated a breakpoint and returns itself, its key or false
//////////////////////////////

@function parse-breakpoint($key, $get-map: true) {
    @if map-has-key($hagrid-breakpoints, $key) {
        @if $get-map == false {
            @return $key;
        }
        @else {
            @return map-get($hagrid-breakpoints, $key);
        }
    }
    @elseif is-mq($key) {
        @return $key;
    }
    @else {
        @return false;
    }
}

// Check if a string is a media query
//////////////////////////////

@function is-mq($string) {
    @if str-starts-with($string, unquote("(")) and str-end-with($string, unquote(")")) {
        @return true;
    }
    @else {
        @return false;
    }
}

// Check if a string starts with a substring
//////////////////////////////

@function str-starts-with($string, $needle) {
  @if type-of($string) != "string" {
    @warn "`str-starts-with` function expecting a string for $string; #{type-of($string)} given.";
    @return false;
  }

  @if type-of($needle) != "string" {
    @warn "`str-starts-with` function expecting a string for $needle; #{type-of($needle)} given.";
    @return false;
  }

  @return str-slice($string, 1, str-length($needle)) == $needle;
}

// Check if a string ends with a substring
//////////////////////////////

@function str-ends-with($string, $needle) {
  @if type-of($string) != "string" {
    @warn "`str-starts-with` function expecting a string for $string; #{type-of($string)} given.";
    @return false;
  }

  @if type-of($needle) != "string" {
    @warn "`str-starts-with` function expecting a string for $needle; #{type-of($needle)} given.";
    @return false;
  }

  @return str-slice($string, -1 * str-length($needle)) == $needle;
}

// Shorthands
//////////////////////////////

@mixin g($modifiers...) {
    @include grid($modifiers...);
}

@mixin i($widths...) {
    @include item($widths...);
}
